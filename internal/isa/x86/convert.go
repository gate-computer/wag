// Copyright (c) 2016 Timo Savola. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package x86

import (
	"github.com/tsavola/wag/abi"
	"github.com/tsavola/wag/internal/gen"
	"github.com/tsavola/wag/internal/gen/link"
	"github.com/tsavola/wag/internal/gen/reg"
	"github.com/tsavola/wag/internal/gen/rodata"
	"github.com/tsavola/wag/internal/gen/val"
	"github.com/tsavola/wag/internal/isa/prop"
)

func (ISA) ConversionOp(f *gen.Func, props uint16, resultType abi.Type, source val.Operand) (result val.Operand) {
	switch props {
	case prop.Wrap:
		return opWrap(f, resultType, source)

	default:
		return commonConversionOp(f, props, resultType, source)
	}
}

func opWrap(f *gen.Func, resultType abi.Type, source val.Operand) val.Operand {
	source.Type = abi.I32 // short mov; useful zeroExt flag
	r, zeroExt := opMaybeResultReg(f, source, false)
	return val.TempRegOperand(resultType, r, zeroExt)
}

func commonConversionOp(f *gen.Func, props uint16, resultType abi.Type, source val.Operand) val.Operand {
	r, zeroExt := opMaybeResultReg(f, source, false)
	// TODO: for int<->float ops: borrow source r, allocate target r

	switch props {
	case prop.ExtendS:
		movsxd.opFromReg(&f.Text, 0, r, r)
		return val.TempRegOperand(resultType, r, false)

	case prop.ExtendU:
		if !zeroExt {
			mov.opFromReg(&f.Text, abi.I32, r, r)
		}
		return val.TempRegOperand(resultType, r, false)

	case prop.Mote:
		cvts2sSSE.opFromReg(&f.Text, source.Type, r, r)
		return val.TempRegOperand(resultType, r, false)

	case prop.TruncS:
		cvttsSSE2si.opReg(&f.Text, source.Type, resultType, RegResult, r)
		f.Regs.Free(source.Type, r)
		return val.TempRegOperand(resultType, RegResult, true)

	case prop.TruncU:
		if resultType == abi.I32 {
			cvttsSSE2si.opReg(&f.Text, source.Type, abi.I64, RegResult, r)
		} else {
			opTruncFloatToUnsignedI64(f, source.Type, r)
		}
		f.Regs.Free(source.Type, r)
		return val.TempRegOperand(resultType, RegResult, false)

	case prop.ConvertS:
		cvtsi2sSSE.opReg(&f.Text, resultType, source.Type, RegResult, r)
		f.Regs.Free(source.Type, r)
		return val.TempRegOperand(resultType, RegResult, false)

	case prop.ConvertU:
		if source.Type == abi.I32 {
			if !zeroExt {
				mov.opFromReg(&f.Text, abi.I32, r, r)
			}
			cvtsi2sSSE.opReg(&f.Text, resultType, abi.I64, RegResult, r)
		} else {
			opConvertUnsignedI64ToFloat(f, resultType, r)
		}
		f.Regs.Free(source.Type, r)
		return val.TempRegOperand(resultType, RegResult, false)

	case prop.Reinterpret:
		if source.Type.Category() == abi.Int {
			movSSE.opFromReg(&f.Text, source.Type, RegResult, r)
		} else {
			movSSE.opToReg(&f.Text, source.Type, RegResult, r)
		}
		f.Regs.Free(source.Type, r)
		return val.TempRegOperand(resultType, RegResult, true)
	}

	panic("unknown conversion op")
}

func opTruncFloatToUnsignedI64(f *gen.Func, sourceType abi.Type, inputReg reg.R) {
	// this algorithm is copied from code generated by gcc and clang:

	roDataAddr := f.RODataAddr
	truncMaskAddr := rodata.MaskAddr(roDataAddr, rodata.MaskTruncBase, sourceType)

	movapSSE.opFromReg(&f.Text, sourceType, RegScratch, inputReg)
	subsSSE.opFromAddr(&f.Text, sourceType, RegScratch, 0, NoIndex, truncMaskAddr)
	cvttsSSE2si.opReg(&f.Text, sourceType, abi.I64, RegResult, RegScratch)
	mov.opFromAddr(&f.Text, abi.I64, RegScratch, 0, NoIndex, roDataAddr+rodata.Mask80Addr64)
	xor.opFromReg(&f.Text, abi.I64, RegScratch, RegResult)
	cvttsSSE2si.opReg(&f.Text, sourceType, abi.I64, RegResult, inputReg)
	ucomisSSE.opFromAddr(&f.Text, sourceType, inputReg, 0, NoIndex, truncMaskAddr)
	cmovae.opFromReg(&f.Text, abi.I64, RegResult, RegScratch)
}

func opConvertUnsignedI64ToFloat(f *gen.Func, resultType abi.Type, inputReg reg.R) {
	// this algorithm is copied from code generated by gcc and clang:

	var done link.L
	var huge link.L

	// TODO: allocate target r

	test.opFromReg(&f.Text, abi.I64, inputReg, inputReg)
	js.rel8.opStub(&f.Text)
	huge.AddSite(f.Text.Addr)

	// max. 63-bit value
	cvtsi2sSSE.opReg(&f.Text, resultType, abi.I64, RegResult, inputReg)

	jmpRel.rel8.opStub(&f.Text)
	done.AddSite(f.Text.Addr)

	huge.Addr = f.Text.Addr
	updateLocalBranches(f.M, &huge)

	// 64-bit value
	mov.opFromReg(&f.Text, abi.I64, RegScratch, inputReg)
	and.opImm(&f.Text, abi.I64, RegScratch, 1)
	shrImm.op(&f.Text, abi.I64, inputReg, 1)
	or.opFromReg(&f.Text, abi.I64, inputReg, RegScratch)
	cvtsi2sSSE.opReg(&f.Text, resultType, abi.I64, RegResult, inputReg)
	addsSSE.opFromReg(&f.Text, resultType, RegResult, RegResult)

	done.Addr = f.Text.Addr
	updateLocalBranches(f.M, &done)
}

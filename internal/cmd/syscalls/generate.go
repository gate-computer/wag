// Copyright (c) 2018 Timo Savola. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"runtime"
	"strings"
	"syscall"
)

const (
	ptr1 = (1 << 0)
	ptr2 = (1 << 1)
	ptr3 = (1 << 2)
	ptr4 = (1 << 3)
)

type call struct {
	name    string
	number  int
	params  int
	ptrMask int
	result  int
}

type variant struct {
	name string
	sig  string
	args string
}

func (sc call) titleName() string {
	return strings.Replace(strings.Title(strings.Replace(sc.name, "_", " ", -1)), " ", "", -1)
}

func (sc call) variants() (vs []variant) {
	var v variant
	v.name = sc.name + "_"
	if sc.params > 0 {
		v.sig += "(param"
		for i := 0; i < sc.params; i++ {
			v.name += "i32"
			v.sig += " i32"
			v.args += fmt.Sprintf("\n      (get_local %d)", i)
		}
		v.sig += ") "
	}

	if sc.result <= 0 {
		vs = append(vs, v)
	}

	if sc.result >= 0 {
		v.name += "_i32"
		v.sig += "(result i32)"
		vs = append(vs, v)
	}
	return
}

func main() {
	libFile, err := ioutil.TempFile("", "")
	if err != nil {
		log.Panic(err)
	}
	defer os.Remove(libFile.Name())
	defer libFile.Close()

	libBuf := bytes.NewBuffer(nil)
	lib := io.MultiWriter(libFile, libBuf)

	decl, err := os.Create("cmd/wasys/syscall.go")
	if err != nil {
		log.Panic(err)
	}
	defer decl.Close()

	impl, err := os.Create(fmt.Sprintf("cmd/wasys/syscall_%s.s", runtime.GOARCH))
	if err != nil {
		log.Panic(err)
	}
	defer impl.Close()

	fmt.Fprintf(lib, "(module\n")

	fmt.Fprintf(decl, "// Generated by internal/cmd/syscalls/generate.go\n\n")
	fmt.Fprintf(decl, "package main\n\n")
	fmt.Fprintf(decl, "import \"encoding/binary\"\n\n")

	fmt.Fprintf(impl, "// Generated by internal/cmd/syscalls/generate.go\n\n")
	fmt.Fprintf(impl, "#include \"textflag.h\"\n")

	for _, sc := range syscalls {
		for _, v := range sc.variants() {
			fmt.Fprintf(lib, "  (import \"env\" \"%s\" (func $sys_%s %s))\n", sc.name, v.name, v.sig)
		}

		fmt.Fprintf(decl, "func import%s() uint64\n", sc.titleName())

		fmt.Fprintf(impl, "\n// func import%s() uint64\n", sc.titleName())
		fmt.Fprintf(impl, "TEXT Â·import%s(SB),$0-8\n", sc.titleName())
		generators[runtime.GOARCH](impl, sc)
	}

	fmt.Fprintln(lib)

	fmt.Fprintf(decl, "\nfunc init() {\n")
	fmt.Fprintf(decl, "\timportVector = make([]byte, %d)\n", (len(syscalls)+4)*8)
	fmt.Fprintf(decl, "\tbinary.LittleEndian.PutUint64(importVector[%d:], importTrapHandler())\n", (len(syscalls)+3)*8)
	fmt.Fprintf(decl, "\tbinary.LittleEndian.PutUint64(importVector[%d:], importGrowMemory())\n", (len(syscalls)+2)*8)
	fmt.Fprintf(decl, "\tbinary.LittleEndian.PutUint64(importVector[%d:], importCurrentMemory())\n", (len(syscalls)+1)*8)

	for i, sc := range syscalls {
		for _, v := range sc.variants() {
			fmt.Fprintf(lib, "  (func (export \"%s\")\n", v.name)
			fmt.Fprintf(lib, "    %s\n", v.sig)
			fmt.Fprintf(lib, "    (call $sys_%s%s))\n\n", v.name, v.args)
		}

		offset := (len(syscalls) - i - 1) * 8
		fmt.Fprintf(decl, "\tbinary.LittleEndian.PutUint64(importVector[%d:], import%s())\n", offset, sc.titleName())
	}

	for i, sc := range syscalls {
		index := -i - 5
		fmt.Fprintf(decl, "\timportFuncs[\"%s\"] = %d\n", sc.name, index)
	}

	fmt.Fprintf(lib, ")\n") // (module)

	fmt.Fprintf(decl, "}\n") // init()

	fmt.Fprintf(decl, "\nfunc setImportVectorMemoryAddr(vec []byte, addr uintptr) {\n")
	fmt.Fprintf(decl, "\tbinary.LittleEndian.PutUint64(vec[%d:], uint64(addr))\n", (len(syscalls)+0)*8)
	fmt.Fprintf(decl, "}\n")

	watToWasm := os.Getenv("WAT2WASM")
	if watToWasm == "" {
		watToWasm = "wat2wasm"
	}

	cmd := exec.Command(watToWasm, "-o", "/dev/stdout", libFile.Name())
	cmd.Stderr = os.Stderr
	libWASM, err := cmd.Output()
	if err != nil {
		log.Panic(err)
	}

	fmt.Fprintf(decl, "\n/*\n")
	fmt.Fprint(decl, libBuf.String())
	fmt.Fprintf(decl, "*/\n")
	fmt.Fprintf(decl, "var libWASM = []byte{\n")
	space := "\t"
	for i, b := range libWASM {
		fmt.Fprintf(decl, "%s0x%02x,", space, b)
		space = " "
		if i%12 == 11 {
			fmt.Fprintln(decl)
			space = "\t"
		}
	}
	if len(libWASM)%12 != 0 {
		fmt.Fprintln(decl)
	}
	fmt.Fprintf(decl, "}\n")
}

var (
	x86Regs = []string{"DI", "SI", "DX", "R10", "R8", "R9"}
	armRegs = []string{"R0", "R1", "R2", "R3", "R4", "R5"}
)

var generators = map[string]func(io.Writer, call){
	"amd64": func(w io.Writer, sc call) {
		fmt.Fprintf(w, "\tLEAQ\tsys%s<>(SB), AX\n", sc.titleName())
		fmt.Fprintf(w, "\tMOVQ\tAX, ret+0(FP)\n")
		fmt.Fprintf(w, "\tRET\n\n")

		fmt.Fprintf(w, "TEXT sys%s<>(SB),NOSPLIT,$0\n", sc.titleName())

		for i := 0; i < sc.params; i++ {
			r := x86Regs[i]

			fmt.Fprintf(w, "\tMOVQ\t%d(SP), %s\n", (sc.params-i)*8, r)

			if (sc.ptrMask & (1 << uint(i))) != 0 {
				fmt.Fprintf(w, "\tANDL\t%s, %s\n", r, r) // zero-extend and test
				fmt.Fprintf(w, "\tJZ\tnull%d\n", i+1)
				fmt.Fprintf(w, "\tADDQ\tR14, %s\n", r)
				fmt.Fprintf(w, "null%d:", i+1)
			}
		}

		fmt.Fprintf(w, "\tMOVL\t$%d, AX\n", sc.number)
		fmt.Fprintf(w, "\tSYSCALL\n")
		fmt.Fprintf(w, "\tMOVQ\tR15, DX\n")
		fmt.Fprintf(w, "\tADDQ\t$0x20, DX\n") // resume routine
		fmt.Fprintf(w, "\tJMP\tDX\n")
	},
	"arm64": func(w io.Writer, sc call) {
		fmt.Fprintf(w, "\tBL\tafter\n\n")

		for i := 0; i < sc.params; i++ {
			r := armRegs[i]

			if (sc.ptrMask & (1 << uint(i))) != 0 {
				fmt.Fprintf(w, "\tMOVD\t$0, %s\n", r)
				fmt.Fprintf(w, "\tMOVW\t%d(R29), %s\n", (sc.params-i-1)*8, r)
				fmt.Fprintf(w, "\tCMPW\t$0, %s\n", r)
				fmt.Fprintf(w, "\tBEQ\tnull%d\n", i+1)
				fmt.Fprintf(w, "\tADD\tR26, %s\n", r)
				fmt.Fprintf(w, "null%d:", i+1)
			} else {
				fmt.Fprintf(w, "\tMOVD\t%d(R29), %s\n", (sc.params-i-1)*8, r)
			}
		}

		fmt.Fprintf(w, "\tMOVD\t$%d, R8\n", sc.number)
		fmt.Fprintf(w, "\tSVC\n")
		fmt.Fprintf(w, "\tMOVD\tR27, R1\n")
		fmt.Fprintf(w, "\tADD\t$0x20, R1\n") // resume routine
		fmt.Fprintf(w, "\tB\t(R1)\n\n")

		fmt.Fprintf(w, "after:\tMOVD\tLR, ret+0(FP)\n")
		fmt.Fprintf(w, "\tRET\n")
	},
}

var syscalls = []call{
	{"read", syscall.SYS_READ, 3, ptr2, 1},
	{"write", syscall.SYS_WRITE, 3, ptr2, 0},
	{"close", syscall.SYS_CLOSE, 1, 0, 1},
	{"lseek", syscall.SYS_LSEEK, 3, 0, 1},
	{"pread", syscall.SYS_PREAD64, 4, ptr2, 1},
	{"pwrite", syscall.SYS_PWRITE64, 4, ptr2, 1},
	{"dup", syscall.SYS_DUP, 1, 0, 1},
	{"getpid", syscall.SYS_GETPID, 0, 0, 1},
	{"sendfile", syscall.SYS_SENDFILE, 4, ptr3, 1},
	{"shutdown", syscall.SYS_SHUTDOWN, 2, 0, 1},
	{"socketpair", syscall.SYS_SOCKETPAIR, 4, ptr4, 1},
	{"flock", syscall.SYS_FLOCK, 2, 0, 1},
	{"fsync", syscall.SYS_FSYNC, 1, 0, 1},
	{"fdatasync", syscall.SYS_FDATASYNC, 1, 0, 1},
	{"truncate", syscall.SYS_TRUNCATE, 2, ptr1, 1},
	{"ftruncate", syscall.SYS_FTRUNCATE, 2, 0, 1},
	{"getcwd", syscall.SYS_GETCWD, 2, ptr1, 1},
	{"chdir", syscall.SYS_CHDIR, 1, ptr1, 1},
	{"fchdir", syscall.SYS_FCHDIR, 1, 0, 1},
	{"fchmod", syscall.SYS_FCHMOD, 2, 0, 1},
	{"fchown", syscall.SYS_FCHOWN, 3, 0, 1},
	{"umask", syscall.SYS_UMASK, 1, 0, 1},
	{"getuid", syscall.SYS_GETUID, 0, 0, 1},
	{"getgid", syscall.SYS_GETGID, 0, 0, 1},
	{"vhangup", syscall.SYS_VHANGUP, 0, 0, 1},
	{"sync", syscall.SYS_SYNC, 0, 0, 1},
	{"gettid", syscall.SYS_GETTID, 0, 0, 1},
	{"posix_fadvise", syscall.SYS_FADVISE64, 4, 0, 1},
	{"_exit", syscall.SYS_EXIT_GROUP, 1, 0, -1},
	{"inotify_init1", syscall.SYS_INOTIFY_INIT1, 0, 0, 1},
	{"inotify_add_watch", syscall.SYS_INOTIFY_ADD_WATCH, 3, ptr2, 1},
	{"inotify_rm_watch", syscall.SYS_INOTIFY_RM_WATCH, 2, 0, 1},
	{"openat", syscall.SYS_OPENAT, 4, ptr2, 1},
	{"mkdirat", syscall.SYS_MKDIRAT, 3, ptr2, 1},
	{"fchownat", syscall.SYS_FCHOWNAT, 5, ptr2, 1},
	{"unlinkat", syscall.SYS_UNLINKAT, 3, ptr2, 1},
	{"renameat", syscall.SYS_RENAMEAT, 4, ptr2 | ptr4, 1},
	{"linkat", syscall.SYS_LINKAT, 5, ptr2 | ptr4, 1},
	{"symlinkat", syscall.SYS_SYMLINKAT, 3, ptr1 | ptr3, 1},
	{"readlinkat", syscall.SYS_READLINKAT, 4, ptr2 | ptr3, 1},
	{"fchmodat", syscall.SYS_FCHMODAT, 4, ptr2, 1},
	{"faccessat", syscall.SYS_FACCESSAT, 4, ptr2, 1},
	{"splice", syscall.SYS_SPLICE, 6, ptr2 | ptr4, 1},
	{"tee", syscall.SYS_TEE, 4, 0, 1},
	{"sync_file_range", syscall.SYS_SYNC_FILE_RANGE, 4, 0, 1},
	{"fallocate", syscall.SYS_FALLOCATE, 4, 0, 1},
	{"eventfd", syscall.SYS_EVENTFD2, 2, 0, 1},
	{"dup3", syscall.SYS_DUP3, 3, 0, 1},
	{"pipe2", syscall.SYS_PIPE2, 2, ptr1, 1},
}

# Copyright (c) 2021 Timo Savola. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

from collections import defaultdict
from glob import glob
from json import load
from os import environ
from re import match
from subprocess import run
from sys import executable, stderr

gofmt = environ.get("GOFMT", "gofmt")


def main():
    run([executable, "specdata.py"], cwd="testdata", check=True)

    text = """// Generated by spec_test.py, DO NOT EDIT!

        package main

        import (
            "testing"

            "gate.computer/wag/wa"
        )"""

    for filename in sorted(glob("testdata/spec/test/core/*.wast")):
        basename = match(r".*/(.*)\.wast$", filename)[1]

        if basename in ("bulk", "linking", "ref_func", "ref_is_null", "ref_null"):
            text += '\n func Test_{}(t *testing.T) {{'.format(basename.replace("-", "_"))
            text += ' t.Skip("{} not supported")'.format(basename)
            text += '} \n'
            continue

        with open("testdata/specdata/{}.json".format(basename)) as f:
            spec = load(f)

        cmdmods = []
        prevmod = None
        nextmod = 0

        for cmd in spec["commands"]:
            skip = None

            if cmd["type"] == "module":
                if "name" in cmd:
                    mod = cmd["name"]
                else:
                    mod = nextmod
                    nextmod += 1
                prevmod = mod
            else:
                try:
                    mod = cmd["action"]["module"]
                except KeyError:
                    mod = prevmod

                for d in cmd.get("action", {}).get("args", []) + cmd.get("expected", []):
                    if d["type"].endswith("ref"):
                        skip = "reference types"

                if cmd["type"] == "assert_malformed":
                    if cmd["text"] == "malformed reference type":
                        skip = "reference types"
                    elif cmd["filename"].endswith(".wat"):
                        skip = "text format"
                elif cmd["type"] == "assert_return":
                    if len(cmd["expected"]) > 1:
                        skip = "multi-value extension"
                elif cmd["type"] == "assert_trap":
                    if cmd["text"] == "uninitialized element":
                        skip = "linking"
                elif cmd["type"] == "assert_unlinkable":
                    skip = "linking"

            cmdmods.append((cmd, mod, skip))

        text += '\n func Test_{}(t *testing.T) {{'.format(basename.replace("-", "_"))

        modules = []
        subtests = False

        for cmd, mod, skip in cmdmods:
            if cmd["type"] == "module":
                text += '\n x{} := instantiateSpecTest(t, {}, {})'.format(var(mod), quote(mod), quote(cmd["filename"]))
                text += '\n t.Cleanup(func() {{ x{}.close(t) }})'.format(var(mod))
                modules.append(mod)
                continue
            elif cmd["type"] == "register":
                text += '\n x{}.register(t) '.format(var(mod))
                continue

            subtests = True

            try:
                field = cmd["action"]["field"]
                assert field.isascii() and all((c.isalnum() or c in "-_.") for c in field)
            except (KeyError, AssertionError):
                testname = "{}:{}".format(cmd["type"], cmd["line"])
            else:
                testname = "{}:{}".format(field, cmd["line"])

            text += '\n t.Run({}, func(t *testing.T) {{'.format(quote(testname))

            if skip:
                text += 't.Skip("{} not supported")'.format(skip)
            else:
                if cmd["type"] == "action":
                    assert not cmd["expected"]
                    act = cmd["action"]
                    assert act["type"] == "invoke"
                    text += 'x{}.invoke(t, {}, {})'.format(var(mod), quote(act["field"]), args(act["args"]))
                elif cmd["type"] == "assert_exhaustion":
                    act = cmd["action"]
                    assert act["type"] == "invoke"
                    text += 'x{}.assertExhaustion(t, {}, {}, {}, {})'.format(var(mod), quote(act["field"]), args(act["args"]), expected(cmd["expected"]), quote(cmd["text"]))
                elif cmd["type"] == "assert_invalid":
                    text += 'assertInvalidSpec(t, {}, {})'.format(quote(cmd["filename"]), quote(cmd["text"]))
                elif cmd["type"] == "assert_malformed":
                    text += 'assertMalformedSpec(t, {}, {})'.format(quote(cmd["filename"]), quote(cmd["text"]))
                elif cmd["type"] == "assert_return":
                    exp = expected(cmd["expected"])
                    act = cmd["action"]
                    if act["type"] == "invoke":
                        text += 'x{}.assertReturnInvoke(t, {}, {}, {})'.format(var(mod), quote(act["field"]), args(act["args"]), exp)
                    elif act["type"] == "get":
                        text += 'x{}.assertReturnGet(t, {}, {})'.format(var(mod), quote(act["field"]), exp)
                    else:
                        assert False, act["type"]
                elif cmd["type"] == "assert_trap":
                    act = cmd["action"]
                    assert act["type"] == "invoke"
                    text += 'x{}.assertTrap(t, {}, {}, {}, {})'.format(var(mod), quote(act["field"]), args(act["args"]), expected(cmd["expected"]), quote(cmd["text"]))
                elif cmd["type"] == "assert_uninstantiable":
                    text += 'assertUninstantiableSpec(t, {}, {})'.format(quote(cmd["filename"]), quote(cmd["text"]))
                else:
                    assert False, cmd

            text += '})'

        if not subtests:
            if modules:
                text += '\n if '
                for i, mod in enumerate(modules):
                    if i > 0:
                        text += ' && '
                    text += ' x{}.unsupported() '.format(var(mod))
                text += ' { t.Skip("no supported modules") }'
            else:
                text += ' t.Skip("no supported tests")'

        text += '\n } \n'

    proc = run([gofmt], input=text, capture_output=True, text=True)
    if proc.stderr:
        stderr.write(proc.stderr)
        exit(proc.returncode or 1)
    if proc.returncode:
        exit(proc.returncode)

    with open("spec_test.go", "w") as f:
        f.write(proc.stdout)


def var(x):
    assert isinstance(x, (int, str))
    return str(x).strip("$").replace(" ", "_")


def quote(s):
    assert s is not None
    s = str(s)
    q = '"'
    for c in s:
        if c == '\\':
            q += r'\\'
        elif c == '"':
            q += r'\"'
        elif c < ' ' or c > '~':
            return quote_as_bytes(s)
        else:
            q += c
    q += '"'
    return q


def quote_as_bytes(s):
    q = 'string([]byte{'
    for i, c in enumerate(s.encode()):
        if i > 0:
            q += ', '
        q += str(c)
    q += '})'
    return q


def args(vector):
    if not vector:
        return "nil"

    r = "[]arg{"

    for i, d in enumerate(vector):
        if i > 0:
            r += ","

        if "value" in d:
            r += "{{ wa.{}, {} }}".format(d["type"].upper(), parse_value(d))
        else:
            r += "{{ Type: wa.{} }}".format(d["type"].upper())

    r += "}"
    return r


def expected(vector):
    if not vector:
        return "arg{}"

    d, = vector
    if "value" in d:
        return "arg{{ wa.{}, {} }}".format(d["type"].upper(), parse_value(d))
    else:
        return "arg{{ Type: wa.{} }}".format(d["type"].upper())


def parse_value(d):
    v = d["value"]
    if v.startswith("nan:"):
        return nan[d["type"]][v]
    return v


nan = {
    "f32": {
        "nan:canonical":  "0x7f800000",
        "nan:arithmetic": "0x7fc00000",
    },
    "f64": {
        "nan:canonical":  "0x7ff8000000000000",
        "nan:arithmetic": "0x7ffc000000000000",
    },
}


if __name__ == "__main__":
    main()
